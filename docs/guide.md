# Детальный пошаговый план разработки бота для spoiler на Node.js + TypeScript

Ниже приведён максимально детальный и реалистичный roadmap с развернутыми задачами каждого этапа.

***

## Этап 1: Подготовка среды (1-2 дня, легкая)

**Шаги:**

1. Установить Node.js (LTS) и TypeScript (`npm install -g typescript ts-node`).
2. Создать структуру проекта, инициализировать `package.json`.
3. Установить необходимые библиотеки (актуально):
    - `@techstark/opencv-js` (OpenCV.js, WebAssembly), `screenshot-desktop`, `robotjs`, `winston`, `@types/node`.
4. Настроить TypeScript (`tsconfig.json`): задать output, target, strict options.
5. Создать базовые конфигурационные файлы (`settings.json`).
6. Git init и .gitignore, подключить систему контроля версий.

**Результат:**
Готовая для разработки среда с нужными зависимостями и конфигами.

***

## Этап 2: Базовая архитектура (2-3 дня, средняя)

**Шаги:**

1. Разработать структуру каталогов (`src/core`, `src/spoiler`, `src/utils`, `assets/templates`).
2. Создать абстрактный класс/интерфейс `Bot`.
3. Создать модули: захват экрана (`Capture.ts`), логирование (`Logger.ts`).
4. Описать основные типы: координаты окна, состояния, параметры спойлера.
5. Реализовать конфигуратор для подгрузки настроек из `.json`.
6. Подготовить шаблоны для дальнейших модулей (заглушки методов).

**Результат:**
Скелет приложения с продуманными интерфейсами и возможностью дальнейшего масштабирования.

***

## Этап 3: Захват и анализ изображений (3-4 дня, высокая)

**Шаги:**

1. Освоить захват экрана с помощью `node-screenshots` или `screenshot-desktop`.
2. Реализовать метод быстрой вырезки ROI из скриншота (обрезка на этапе RGBA до формирования `cv.Mat`).
3. Подключить OpenCV.js (`@techstark/opencv-js`). Научиться конвертировать RGBA-буфер → `cv.Mat`.
4. Создать базовые функции преобразования изображений: перевод в grayscale, бинаризация.
5. Визуализировать полученные изображения (вывод в файл или окно).
6. Проверить производительность: добиться <100 мс на полный захват и первичную обработку.

**Результат:**
Модуль, способный захватывать и оперативно обрабатывать игровой экран.

***

## Этап 4: Обнаружение целей (4-5 дней, очень высокая)

**Шаги:**

1. Собрать библиотеку шаблонов: полоски HP, надписи, иконки.
2. Разработать цветовой и/или OCR-анализ для определения имён мобов.
3. Реализовать морфологические операции (`cv.morphologyEx`, ядра 50x5, как в лучших примерах).
4. Написать функцию поиска потенциальных целей среди контуров на экране.
5. Добавить функцию валидации — наведение на цель, подтверждение подсветки, определение “живой/мертвой”.
6. Протестировать обнаружение целей в реальных условиях (на разных локациях и при различном UI).

**Результат:**
Надёжная система поиска и идентификации врага для spoiler логики.

***

## Этап 5: Эмуляция действий (2-3 дня, средняя)

**Шаги:**

1. Подключить и освоить `robotjs` для эмуляции нажатий мыши и клавиатуры.
2. Реализовать функцию клика по координатам и плавное наведение мыши.
3. Создать абстракции для использования скиллов (нажатия F1/F2/F3), движения, открытия меню и возврата в город.
4. Реализовать fail-safe обработку — экстренная остановка через клавишу (например, ESC).
5. Протестировать на простых действиях (открытие инвентаря, выбор цели).

**Результат:**
Полный программный контроль над игровым окном, эмулирующий активного пользователя.

***

## Этап 6: Логика spoiler класса (3-4 дня, высокая)

**Шаги:**

1. Формализовать ротацию: поиск цели → spoil → damage → sweep (настройка hotkey через конфиг).
2. Добавить мониторинг MP/HP: автоиспользование банок, логика восстановления.
3. Реализовать систему событий: успешный spoil, неудача, сброс/повтор.
4. Специализировать алгоритм поиска целей для учета потребностей spoiler (например, искать групповые скопления мобов).
5. Протестировать поведение на динамических и статических группах.

**Результат:**
Функционал сочетающий всю механику spoiler класса, практически способный фармить “ручками”.

***

## Этап 7: Система состояний (2-3 дня, средняя)

**Шаги:**

1. Реализовать state machine (`enum`): INIT, SEARCHING, SPOILING, ATTACKING, SWEEPING, RETURNING.
2. Для каждого состояния задать методы обработки входа/выхода и возможные переходы.
3. Организовать “циклы жизни моба”: появление, атака, смерть, дроп, сбор, возврат к поиску.
4. Добавить временные задержки, условия прерывания и перехода в safe-моды при сбоях.

**Результат:**
Умная логика поведения, реагирующая на игровые и внеигровые события.

***

## Этап 8: Мониторинг и отладка (2-3 дня, средняя)

**Шаги:**

1. Включить централизованное логирование (`winston`), добавить уровни Debug/Info/Error.
2. Сделать on-screen overlay (в отдельном окне/консоли), рисовать прямоугольники целей/статус бота.
3. Вести метрику: FPS обработки, количество найденных целей, среднее время цикла.
4. Реализовать сбор crash- и debug-логов в файл.
5. Вывести ключевые параметры работы (HP/MP/текущее состояние) для on-the-fly диагностики.

**Результат:**
Production-ready система мониторинга и визуального контроля.

***

## Этап 9: Оптимизация и полировка (3-4 дня, высокая)

**Шаги:**

1. Провести профилирование — выявить bottlenecks (чаще всего: обработка изображений и роботизация).
2. Оптимизировать “узкие места”: уменьшить частоту захвата, оптимизировать ROI, ввести кэширование шаблонов.
3. Улучшить стабильность: добавить recovery от ошибок захвата, lag spikes, ошибочных переходов по состояниям.
4. Протестировать в реальных сессиях по 1-2 часа.
5. Подготовить систему для возможной дальнейшей генерализации под другие классы.

**Результат:**
Быстрый и устойчивый бот, без заметных лагов и неожиданных вылетов.

***

## Этап 10: Тестирование и документация (2-3 дня, легкая)

**Шаги:**

1. Написать простейшие unit и integration тесты для ключевых модулей.
2. Подготовить README: описание запуска, необходимые права, настройки.
3. Описать архитектуру, конфиг, FAQ, секцию “безопасность” (ограничить публичное применение).
4. Провести итоговую “боевую” сессию на тестовом сервере.
5. Сделать резервные копии шаблонов, кода, конфигов.

**Результат:**
Документированный, поддерживаемый продукт, готовый к безопасному использованию.

***

***

**При необходимости любой этап может быть расписан ещё глубже – готов раскрыть алгоритмы, методы работы с Windows API, нюансы оптимизации и ключевой код!**
