# Экстремально подробный поэтапный план создания бота Lineage 2 Spoiler (Node.js + TypeScript, Windows)


***

## Этап 1: Подготовка среды

### 1.1 Установка и настройка инструментов

- **Node.js:** Скачать последнюю LTS версию с официального сайта.
- **TypeScript:** `npm install -g typescript ts-node`
- **Графический редактор:** VSCode или WebStorm — настроить плагины для TypeScript, jsdoc и форматирования.
- **Git:** Установить, добавить в PATH.


### 1.2 Инициализация репозитория

- `git init` в корне проекта.
- Добавить `.gitignore` с исключением `/node_modules`, `/dist`, `*.log`, `*.png`.


### 1.3 package.json и библиотеки

- `npm init -y`
- Установить зависимости (актуально):
`npm install @techstark/opencv-js robotjs screenshot-desktop winston`
- Примечание: ранее использовался `opencv4nodejs`, но из-за нативной сборки (node-gyp/MSBuild) он был заменён на WebAssembly-версию OpenCV.js — `@techstark/opencv-js`.
- Установить типы:
`npm install --save-dev @types/node @types/robotjs`


### 1.4 TypeScript-конфиг

- `tsc --init`
- Настроить `tsconfig.json`: target = es2020, rootDir = src, outDir = dist, strict = true, moduleResolution = node.


### 1.5 Начальная структура

```
/src
   /core
   /spoiler
   /utils
   /config
   /assets/templates
/dist
/README.md
/settings.json
```


### 1.6 Примеры конфига

```json
{
  "gameWindowName": "Lineage II",
  "skills": { "spoil": "F1", "damage": "F2", "sweep": "F3", "heal": "F4" },
  "loopIntervalMs": 500,
  "hpBarCoords": [100,40,255,45]
}
```


***

## Этап 2: Базовая архитектура

### 2.1 Проектирование интерфейсов и основных классов

- **Bot:** Абстрактный класс, описывающий общую логику (init, start, stop, loop).
- **GameWindow:** Класс/модуль для управления окном (определение координат, проверка foreground, активация).
- **Logger:** Singleton с уровнями логирования (info/debug/error).


### 2.2 Скелет приложения

- Создать main.ts: точку входа — запуск, graceful shutdown (catch SIGINT).
- Прописать основные интерфейсы: IConfig, IState, IAction, IImageInput.


### 2.3 Подключение конфига

- **Config.ts:** safe loader, schema checker.
- Проверка наличия файлов и ключей, загрузка параметров в глобальный singleton.


### 2.4 Заглушки модулей

- Экспортировать все ключевые методы (например, core/Capture.ts — `getScreen`, `getGameROI`).
- Написать jsdoc для всех классов и методов, добавить TODO-комментарии с будущими задачами.

***

## Этап 3: Захват и анализ изображений

### 3.1 Захват экрана

- Использовать `node-screenshots` или `screenshot-desktop`: реализовать функцию захвата по имени окна или fullscreen.
- Добавить в Capture.ts универсальную функцию:
    - Фильтрация по костылю (например, удалять области вне bounds Lineage II окна).
    - Преобразование результата в Mat OpenCV.


### 3.2 Работа с ROI

- Функция `extractGameArea(buffer, bounds: [x, y, w, h])` — вырезать только игровую зону.
- Возможность передачи ROI для ускорения повторных обработок.


### 3.3 Подключение и тестирование OpenCV

- Импортировать OpenCV.js (`@techstark/opencv-js`); научиться формировать `cv.Mat` из RGBA-буфера, проводить конвертацию в grayscale и бинаризацию.
- Проверить на скриншотах: grayscale, threshold, сохранение выходных файлов.


### 3.4 Встроенная визуализация

- Протестировать overlay: выводить обработанные и исходные картинки в отдельное окно через cv.imshow или писать temp-файл и открывать.


### 3.5 Замер производительности

- Добавить замер времени (performance.now()), провести тесты в цикле.
- Цель: полный цикл захвата и преобразования от 30 до 100мс.

***

## Этап 4: Обнаружение целей

### 4.1 Подготовка шаблонов

- Собрать скриншоты полоски HP, target highlight, spoil/sweep анимаций.
- Хранить в /assets/templates, стандартизировать имена.


### 4.2 Алгоритмы компьютерного зрения

- Применить threshold к ROI для выделения нужного цвета/текста.
- Для белых надписей мобов — threshold (252,255), MORPH_CLOSE с ядром (50,5), найти контуры.
- При необходимости — добавить OCR (pytesseract.js) для распознавания текста (опционально).


### 4.3 Поиск врагов

- Для каждого найденного контура проверить размер (area), положение (например, не в области чата/party window).
- Приоритет для центральных областей и “свежих” целей.


### 4.4 Наведение и валидация

- Реализовать виртуальное "наведение": плавно двигать мышь с помощью robotjs.
- Кликнуть на центр найденной области, дождаться визуального подтверждения (например, изменение highlight или появление полоски HP).
- При необходимости повторить попытку или сменить цель.


### 4.5 Работа в нестандартных ситуациях

- Добавить fallback: если цель не найдена несколько циклов — вращение камеры, перемещение влево/вправо, логирование неудачных кадров.

***

## Этап 5: Эмуляция действий

### 5.1 Автоматизация через robotjs

- Использовать robotjs или аналог для:
    - эмуляции мыши (`moveMouseSmooth`, `mouseClick`),
    - эмуляции клавиатуры (`keyTap` по hotkey из конфига).


### 5.2 Абстракции действий

- Написать функции: `spoil()`, `damage()`, `sweep()`, `heal()`, `targetNext()`.
- Все координаты для mouseClick брать из обнаруженного ROI.


### 5.3 Fail-safe и контроль

- Клавиша экстренной остановки — глобальный listener на ESC.
- При внезапных ошибках или сбоях автоматический возврат курсора, перевод в безопасный режим (idle).


### 5.4 Тестирование с игрой

- Проверить работу на dummy-действиях: выбор NPC, клик по снаряжению, открытие меню.
- Логировать все действия для post-mortem анализа.

***

## Этап 6: Логика spoiler класса

### 6.1 Продуманная ротация

- Состояния: поиск цели — spoil — дожидание успешного spoil — damage — sweep (если возможно) — следующий моб.
- Управление последовательностью hotkey, синхронизация с визуальным подтверждением (по HP/dropped loot).


### 6.2 Мониторинг ресурсов (HP/MP)

- Функции чтения полосок MP/HP (аналогично детекции HP врага, но координаты из конфига).
- Автоматическое использование банок/скиллов для восстановления, если уровень MP падает ниже установленного порога.


### 6.3 Обработка исключений

- Если spoil or sweep не удаётся — пробовать повторно.
- При отсутствии успеха в течение N секунд — переключаться на новую цель.


### 6.4 Расширенные фичи

- Распознавание баффов (например, отрисовка иконок баффов рядом с полоской HP).
- Учет party, при необходимости: если кто-либо использует spoil поблизости — избегать “гонки” за дропом.

***

## Этап 7: Система состояний

### 7.1 State machine development

- Enum типов: INITIALIZING, SEARCHING, TARGETING, SPOILING, ATTACKING, SWEEPING, RECOVERING, IDLE, RETURNING.
- Каждый state — отдельный метод обработки.
- Выделить триггеры переходов (изменения HP, появление дропа, достижения минимального MP/HP).


### 7.2 Циклы жизни

- После каждого state обязательный update: проверка ресурса времени, подтверждение действий, переход на error/idle при fail.


### 7.3 Аварийные сценарии

- Если неожиданная смерть — переход в RETURNING, выполнение автоматических восстановительных действий (например, перемещение в город, запуск маршрута восстановления).

***

## Этап 8: Мониторинг, логирование и отладка

### 8.1 Логирование

- Winston или аналог с уровнями: debug, info, warn, error.
- Ротация логов, сбор статистики по действиям.


### 8.2 Визуализация

- Режим overlay с отрисовкой выделенных целей, выделением области действия (можно — через вывод окна OpenCV, можно — через генерацию временных файлов).
- Счетчики FPS, число найденных целей, текущий статус state-machine выводить в overlay и в лог.


### 8.3 Метрики

- Вести замеры: средняя задержка цикла, производительность CPU, число false positive/negative на цели.


### 8.4 Аварийные дампы

- При критических ошибках — сохранять last screenshot, стек-дамп, конфиг, инициировать restart.

***

## Этап 9: Оптимизация и полировка

### 9.1 Профилирование

- Использовать профайлеры Node.js (`node --prof`, Chrome DevTools) для поиска узких мест.
- Тестировать на больших локациях, в пиковые часы.


### 9.2 Ускорение алгоритмов

- Кэшировать шаблоны, ограничить область поиска мобов (ROI).
- Снижать частоту обработки вне боевого состояния.
- Либо поднять приоритет процесса при серьезных замесах.


### 9.3 Отказоустойчивость

- Реализовать пул перезапускаемых потоков.
- Автоматическое переключение на safe mode при нештатных ситуациях.


### 9.4 User-experience

- Добавить адаптивные задержки, случайные тайминги для минимизации подозрений.
- Сделать friendly overlay-индикаторы.

***

## Этап 10: Тестирование и документация

### 10.1 Unit и Integration тесты

- Для каждого core-модуля сделать простейший тест: захват ROI, определение HP, успешная эмуляция spoil/sweep.


### 10.2 Документация

- Полный README: краткое описание, установка, настройка, как сменить хоткеи и координаты, запуск, аварийное завершение.
- FAQ: типовые проблемы с установкой, ответы по логам.
- Раздел “этика использования” — только для обучения!


### 10.3 Финализация/backup

- Создать резервную копию кода, шаблонов и настроек.
- Провести “боевой” тестовый ран — повторить все ключевые сценарии в реальной сессии (лучше на неосновном аккаунте на офлайн сервере).

***

**Если нужно расписать пример кода для этапа/модуля — укажи интересующий этап, объект или алгоритм, и я пошагово опишу реализацию с пояснениями и фрагментами кода.**

